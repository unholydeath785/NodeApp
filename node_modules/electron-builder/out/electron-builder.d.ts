declare module 'electron-builder/src/awaiter' {
  
  function tsAwaiter(thisArg: any, _arguments: any, ignored: any, generator: Function): any
}

declare module 'electron-builder/src/builder' {
  import { Packager } from 'electron-builder/src/packager'
  import { PackagerOptions } from 'electron-builder/src/platformPackager'
  import { PublishOptions, Publisher } from 'electron-builder/src/gitHubPublisher'
  import { InfoRetriever } from 'electron-builder/src/repositoryInfo'

  function createPublisher(packager: Packager, options: BuildOptions, repoSlug: InfoRetriever, isPublishOptionGuessed?: boolean): Promise<Publisher>

  interface BuildOptions extends PackagerOptions, PublishOptions {
  }

  function build(options?: BuildOptions): Promise<any>
}

declare module 'electron-builder/src/codeSign' {
  import { Promise as BluebirdPromise } from "bluebird"

  interface CodeSigningInfo {
    cscName: string
    cscKeychainName?: string
  }

  function generateKeychainName(): string

  function createKeychain(keychainName: string, cscLink: string, cscKeyPassword: string): Promise<CodeSigningInfo>

  function sign(path: string, options: CodeSigningInfo): BluebirdPromise<any>

  function deleteKeychain(keychainName: string, ignoreNotFound?: boolean): BluebirdPromise<any>

  function downloadCertificate(cscLink: string): Promise<string>
}

declare module 'electron-builder/src/errorMessages' {
  const buildIsMissed: string
  const authorEmailIsMissed: string
}

declare module 'electron-builder/src/gitHubPublisher' {
  import { Release } from "gh-release"
  import { Promise as BluebirdPromise } from "bluebird"

  interface Publisher {
    upload(path: string): Promise<any>
  }

  interface PublishOptions {
    publish?: "onTag" | "onTagOrDraft" | "always" | "never"
    githubToken?: string
  }

  class GitHubPublisher implements Publisher {
    releasePromise: Promise<Release>
    constructor(owner: string, repo: string, version: string, token: string, createReleaseIfNotExists?: boolean)
    upload(path: string): Promise<void>
    deleteRelease(): BluebirdPromise<void>
  }
}

declare module 'electron-builder/src/gitHubRequest' {
  import { RequestOptions } from "https"
  import { IncomingMessage, ClientRequest } from "http"
  import { Promise as BluebirdPromise } from "bluebird"

  function gitHubRequest<T>(path: string, token: string, data?: {
    [name: string]: any
  }, method?: string): BluebirdPromise<T>

  function doGitHubRequest<T>(options: RequestOptions, token: string, requestProcessor: (request: ClientRequest, reject: (error: Error) => void) => void): BluebirdPromise<T>

  class HttpError extends Error {
    response: IncomingMessage
    description: any
    constructor(response: IncomingMessage, description?: any)
  }
}

declare module 'electron-builder/src/httpRequest' {
  import { ClientRequest } from "http"
  import { Promise as BluebirdPromise } from "bluebird"
  const download: (arg1: string, arg2: string) => BluebirdPromise<{}>

  function addTimeOutHandler(request: ClientRequest, callback: (error: Error | string) => void): void
}

declare module 'electron-builder/src/linuxPackager' {
  import { PlatformPackager, BuildInfo } from 'electron-builder/src/platformPackager'

  class LinuxPackager extends PlatformPackager<DebOptions> {
    desktopIcons: Promise<Array<string>>
    constructor(info: BuildInfo)
    getBuildConfigurationKey(): string
    packageInDistributableFormat(outDir: string, appOutDir: string): Promise<any>
  }

  interface DebOptions {
    title: string
    comment: string
    version: string
    arch: number
    maintainer: string
    executable: string
    target: string
    desktopTemplate?: string
    desktop?: string
    dirs?: Array<string>
  }
}

declare module 'electron-builder/src/macPackager' {
  import { PlatformPackager, BuildInfo } from 'electron-builder/src/platformPackager'
  import { CodeSigningInfo } from 'electron-builder/src/codeSign'

  default class MacPackager extends PlatformPackager<appdmg.Specification> {
    codeSigningInfo: Promise<CodeSigningInfo>
    constructor(info: BuildInfo, cleanupTasks: Array<() => Promise<any>>)
    getBuildConfigurationKey(): string
    pack(platform: string, outDir: string, appOutDir: string): Promise<any>
    packageInDistributableFormat(outDir: string, appOutDir: string): Promise<any>
  }
}

declare module 'electron-builder/src/packager' {
  import { EventEmitter } from "events"
  import { AppMetadata, InfoRetriever } from 'electron-builder/src/repositoryInfo'
  import { PackagerOptions, BuildInfo, DevMetadata } from 'electron-builder/src/platformPackager'

  class Packager implements BuildInfo {
    options: PackagerOptions
    repositoryInfo: InfoRetriever
    projectDir: string
    appDir: string
    metadata: AppMetadata
    devMetadata: DevMetadata
    electronVersion: string
    eventEmitter: EventEmitter
    constructor(options: PackagerOptions, repositoryInfo?: InfoRetriever)
    artifactCreated(handler: (path: string) => void): Packager
    devPackageFile: string
    build(): Promise<any>
  }
}

declare module 'electron-builder/src/platformPackager' {
  import { AppMetadata, InfoRetriever, ProjectMetadataProvider, Metadata } from 'electron-builder/src/repositoryInfo'
  import EventEmitter = NodeJS.EventEmitter

  interface DevMetadata extends Metadata {
    build: DevBuildMetadata
  }

  interface DevBuildMetadata {
    osx: appdmg.Specification
    win: any
    linux: any
  }

  interface PackagerOptions {
    arch?: string
    dist?: boolean
    githubToken?: string
    sign?: string
    platform?: Array<string>
    target?: Array<string>
    appDir?: string
    projectDir?: string
    cscLink?: string
    cscKeyPassword?: string
  }

  interface BuildInfo extends ProjectMetadataProvider {
    options: PackagerOptions
    devMetadata: DevMetadata
    projectDir: string
    appDir: string
    electronVersion: string
    repositoryInfo: InfoRetriever
    eventEmitter: EventEmitter
  }

  abstract class PlatformPackager<DC> implements ProjectMetadataProvider {
    protected info: BuildInfo
    protected options: PackagerOptions
    protected projectDir: string
    metadata: AppMetadata
    devMetadata: Metadata
    customDistOptions: DC
    currentArch: string
    protected abstract getBuildConfigurationKey(): string
    constructor(info: BuildInfo)
    protected dispatchArtifactCreated(path: string): void
    pack(platform: string, outDir: string, appOutDir: string): Promise<any>
    abstract packageInDistributableFormat(outDir: string, appOutDir: string): Promise<any>
  }
}

declare module 'electron-builder/src/promise' {
  import { Promise as BluebirdPromise } from "bluebird"

  function printErrorAndExit(error: Error): void

  function executeFinally(promise: Promise<any>, task: (error?: Error) => Promise<any>): Promise<any>

  class NestedError extends Error {
    constructor(errors: Array<Error>, message?: string)
  }

  function all(promises: Array<Promise<any>>): BluebirdPromise<any>
}

declare module 'electron-builder/src/promisifed-fs' {
  import * as fs from "fs"
  import { Promise as BluebirdPromise } from "bluebird"

  function readText(file: string): BluebirdPromise<string>

  function deleteFile(path: string, ignoreIfNotExists?: boolean): BluebirdPromise<any>

  function renameFile(oldPath: string, newPath: string): BluebirdPromise<string>

  function stat(path: string): BluebirdPromise<fs.Stats>
}

declare module 'electron-builder/src/repositoryInfo' {
  import { Info } from "hosted-git-info"

  interface RepositoryInfo {
    url: string
  }

  interface Metadata {
    repository: string | RepositoryInfo
  }

  interface MetadataAuthor {
    name: string
    email: string
  }

  interface AppMetadata extends Metadata {
    version: string
    name: string
    description: string
    author: MetadataAuthor
    build: BuildMetadata
    windowsPackager: any
  }

  interface BuildMetadata {
    iconUrl: string
  }

  interface ProjectMetadataProvider {
    metadata: AppMetadata
    devMetadata: Metadata
  }

  interface RepositorySlug {
    user: string
    project: string
  }

  class InfoRetriever {
    _info: Promise<Info>
    getInfo(provider: ProjectMetadataProvider): Promise<Info>
  }
}

declare module 'electron-builder/src/util' {
  import { Promise as BluebirdPromise } from "bluebird"
  import "source-map-support/register"
  const log: (message?: any, ...optionalParams: any[]) => void
  const DEFAULT_APP_DIR_NAME: string
  const commonArgs: any[]
  const readPackageJson: (arg1: string) => BluebirdPromise<any>

  function installDependencies(appDir: string, arch: string, electronVersion: string): BluebirdPromise<any>

  interface BaseExecOptions {
    cwd?: string
    env?: any
    stdio?: any
  }

  interface ExecOptions extends BaseExecOptions {
    customFds?: any
    encoding?: string
    timeout?: number
    maxBuffer?: number
    killSignal?: string
  }

  interface SpawnOptions extends BaseExecOptions {
    custom?: any
    detached?: boolean
  }

  function exec(file: string, args?: string[], options?: ExecOptions): BluebirdPromise<Buffer[]>

  function spawn(command: string, args?: string[], options?: SpawnOptions): BluebirdPromise<any>

  function getElectronVersion(packageData: any, filePath: string): string
}

declare module 'electron-builder/src/winPackager' {
  import { PlatformPackager, BuildInfo } from 'electron-builder/src/platformPackager'

  default class WinPackager extends PlatformPackager<any> {
    certFilePromise: Promise<string>
    isNsis: boolean
    constructor(info: BuildInfo, cleanupTasks: Array<() => Promise<any>>)
    getBuildConfigurationKey(): string
    pack(platform: string, outDir: string, appOutDir: string): Promise<any>
    packageInDistributableFormat(outDir: string, appOutDir: string): Promise<any>
  }
}

